#!/usr/bin/env python
#
# cavervolume: volume of protein cavity determined by CAVER Analyst 2.0
#    Copyright (C) 2025  David Stokes 
#           stokes@nyu.edu
#           Dept. of Biochemistry and Molecular Pharmacology
#           NYU School of Medicine
#           550 First Ave
#           New York, NY 10016   USA
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#


# usage: cavervolume.py filename.pdb


# initial code generated by chatgpt:
# "create python program to calculate internal volume
#     encapsulated by overlapping spheres"
#
# To calculate the internal volume encapsulated by overlapping spheres, we are dealing with a union of 3D volumes—this is a classic problem in computational geometry.
#
# Because analytical computation of the exact union volume for multiple overlapping spheres is complex (especially for more than two spheres), we’ll use a Monte Carlo integration method, which provides an approximate but practical solution.
#
# Input: A list of spheres, each defined by a center (x, y, z) and a radius r.
#
# Bounding Box: Compute the bounding box enclosing all spheres.
#
# Sampling: Use Monte Carlo sampling inside the bounding box to estimate the fraction of points inside any sphere.
#
# Volume Estimate: Multiply that fraction by the volume of the bounding box.

#python2.x compatibility
from __future__ import print_function
import platform

import sys
import numpy as np

def read_spheres_from_file(filename):
    spheres = []
    with open(filename, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) > 0:   # skip blank lines
                if parts[0] == 'ATOM':
                    r = float(parts[-1])
                    z = float(parts[-2])
                    y = float(parts[-3])
                    x = float(parts[-4])
                    # x, y, z, r = map(float, parts)
                    print(x,y,z,r)
                    spheres.append((x, y, z, r))
    return spheres

def is_inside_any_sphere(point, spheres):
    x, y, z = point
    for cx, cy, cz, r in spheres:
        if (x - cx)**2 + (y - cy)**2 + (z - cz)**2 <= r**2:
            return True
    return False

def estimate_union_volume(spheres, num_samples=1_000_000):
    xs = [cx for cx, cy, cz, r in spheres]
    ys = [cy for cx, cy, cz, r in spheres]
    zs = [cz for cx, cy, cz, r in spheres]
    rs = [r for cx, cy, cz, r in spheres]

    min_x = min(cx - r for cx, r in zip(xs, rs))
    max_x = max(cx + r for cx, r in zip(xs, rs))
    min_y = min(cy - r for cy, r in zip(ys, rs))
    max_y = max(cy + r for cy, r in zip(ys, rs))
    min_z = min(cz - r for cz, r in zip(zs, rs))
    max_z = max(cz + r for cz, r in zip(zs, rs))

    points = np.random.uniform(
        low=(min_x, min_y, min_z),
        high=(max_x, max_y, max_z),
        size=(num_samples, 3)
    )

    count_inside = 0
    for point in points:
        if is_inside_any_sphere(point, spheres):
            count_inside += 1

    box_volume = (max_x - min_x) * (max_y - min_y) * (max_z - min_z)
    fraction_inside = count_inside / num_samples
    estimated_volume = box_volume * fraction_inside

    return estimated_volume

if __name__ == "__main__":
#    filename = "spheres.txt"  # Path to your input file
    if len(sys.argv) < 2:
        print('usage: cavervolume.py filename.pdb')
        sys.exit()
    else:
        filename = sys.argv[1]
    spheres = read_spheres_from_file(filename)
    if not spheres:
        print("No valid spheres found in the file.")
    else:
        volume = estimate_union_volume(spheres, num_samples=1_000_000)
        print(f"Estimated internal volume: {volume:.4f} Angstrom^3")
